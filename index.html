<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PCI Helper Client App</title>

  <!-- Genesys Client App SDK -->
  <script src="https://apps.mypurecloud.com/client-apps/sdk/purecloud-client-app-sdk.js"></script>

  <!--
    NOTE:
    - GitHub Pages is static, so CSP here is best-effort only (headers are better).
    - Keep this app free of secrets.
    - This version supports a "plumbing test mode" so you can prove wrapper <-> client app messaging works
      before you build the backend.
  -->
  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://apps.mypurecloud.com 'unsafe-inline';
          connect-src 'self' https://YOUR-BACKEND;
        ">
</head>

<body>
<script>
  /**
   * CONFIG
   */

  // Origin(s) allowed to send START_PCI_PAYMENT
  // For GitHub Pages wrappers, this is usually just the GitHub Pages origin:
  const ALLOWED_ORIGINS = [
    'https://dimitri303.github.io'
  ];

  // Set to true to prove the message flow works without needing a backend.
  // In this mode we return dummy sid/bt/rt values.
  const PLUMBING_TEST_MODE = true;

  // Only used when PLUMBING_TEST_MODE === false
  const BACKEND_START_URL = 'https://YOUR-BACKEND/start-pci-session';
  const BACKEND_TIMEOUT_MS = 10000;

  // Genesys region for your org (euw1 = Dublin)
  const clientApp = new window.purecloud.apps.ClientApp({
    pcEnvironment: 'euwest1'
  });

  clientApp.lifecycle.ready
    .then(() => console.log('PCI Helper Client App ready'))
    .catch(err => console.error('Client App lifecycle error', err));

  /**
   * Utility: safe reply back to wrapper
   */
  function makeReply(event) {
    return (payload) => {
      try {
        event.source.postMessage(payload, event.origin);
      } catch (e) {
        console.error('postMessage failed', e);
      }
    };
  }

  /**
   * Listen for messages from the wrapper iframe
   */
  window.addEventListener('message', async (event) => {
    // Origin validation
    if (!event || !event.origin || !ALLOWED_ORIGINS.includes(event.origin)) {
      return;
    }

    // Validate message
    if (!event.data || event.data.type !== 'START_PCI_PAYMENT') return;
    if (!event.source) return;

    const reply = makeReply(event);

    reply({ type: 'PCI_SESSION_STARTING' });

    try {
      // Get the active interaction
      const interaction = await clientApp.interaction.getInteraction();
      if (!interaction || !interaction.id) {
        throw new Error('No active interaction found');
      }

      const conversationId = interaction.id;
      console.log('Received START_PCI_PAYMENT for conversation', conversationId);

      // 1) Plumbing test mode: return dummy data so you can prove wrapper receives it
      if (PLUMBING_TEST_MODE) {
        console.log('PLUMBING_TEST_MODE enabled: returning dummy sid/bt/rt');
        reply({
          type: 'PCI_SESSION_READY',
          sid: 'TEST_SID',
          bt: 'TEST_BT',
          rt: 'TEST_RT'
        });
        return;
      }

      // 2) Real mode: call backend to start PCI session and secure IVR leg
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), BACKEND_TIMEOUT_MS);

      const response = await fetch(BACKEND_START_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ conversationId }),
        signal: controller.signal
      });

      clearTimeout(timer);

      if (!response.ok) {
        let errText = '';
        try { errText = await response.text(); } catch (e) { /* ignore */ }
        throw new Error(
          `Backend failed to start PCI session (status ${response.status})` +
          (errText ? `: ${errText}` : '')
        );
      }

      const data = await response.json();

      if (!data || !data.sid || !data.bt || !data.rt) {
        throw new Error('Backend returned incomplete PCI session data');
      }

      reply({
        type: 'PCI_SESSION_READY',
        sid: data.sid,
        bt: data.bt,
        rt: data.rt
      });

    } catch (err) {
      console.error('PCI start failed', err);

      reply({
        type: 'PCI_SESSION_ERROR',
        message: err && err.name === 'AbortError'
          ? 'PCI start timed out'
          : (err && err.message) || 'PCI start failed'
      });
    }
  });
</script>
</body>
</html>
